# Redis使用

## 1、启动redis服务

```shell
#redis初始不是后台运行的，需要修改配置文件改成后台运行
cd /usr/local/bin/conf
vim redis.conf
#修改daemonize 这个配置项，默认是no 改为yes
daemonize yes

#修改完后启动服务
#进入bin目录
cd ..
redis-server conf/redis.conf

#启动之后使用redis-cli命令指定连接端口
redis-cli -p 6379
127.0.0.1:6379> 
#启动成功
#关闭服务
127.0.0.1:6379> shutdown
```

## 2、压力测试

```shell
#使用官方自带的工具进行并发请求压力测试
#-h 指定服务器主机名 -p 指定服务器端口 -c 指定并发连接数 -n 指定请求数
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
```

## 3、Redis的基本知识

​	redis默认有16个数据库， 默认使用的是第0个。

​	可以使用select进行切换数据库

```shell
127.0.0.1:6379> select 1	#切换数据库
OK
127.0.0.1:6379[1]> keys *	#查看DB大小
(empty array)
127.0.0.1:6379> flushdb		#清空数据库
OK
127.0.0.1:6379> flushall	#清空所有数据库
OK	
```

>Redis是单线程的，但是很快

​	Redis为什么单线程还这么快

​	1、误区1：高性能的服务器一定是多线程的？

​	2、误区2：多线程（CPU上下文会切换）一定比单线程效率高吗？

​	核心：redis是将所有的数据全部存放在内存中的，所以使用单线程去				操作就是效率最高的，多线程（CPU上下文切换：耗时的操				作！），对于内存系统来说，如果没有上下文切换效率就是最				高的！多次读写都是在一个CPU上的，在内存情况下，这个就				是最佳的方案！

>Redis的五大基本类型的命令可以去redis中文网查看
>
>http://www.redis.cn/



## 4、Redis事务

Redis事务本质：一组命令的集合，一起执行，不允许被打断

一次性、顺序性、排他性！执行一些列的命令

==Redis的单条命令是保证原子性的，但是事务不保证原子性==

==Redis事务没有隔离级别的概念！==

==所有的命令在事务中，并没有被执行！只有发起执行命令的时候才会执行==

redis的事务：

- 开启事务（multi）

- 命令入队（ ....redis命令 ）

- 执行事务（exec）

> 正常执行事务！

```shell
127.0.0.1:6379> MULTI	#开始事务
OK
127.0.0.1:6379(TX)> set k1 k1 #一些redis命令入队
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED
127.0.0.1:6379(TX)> DEL k1
QUEUED
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> set k3 v3
QUEUED
127.0.0.1:6379(TX)> exec	#执行事务
1) OK
2) OK
3) (integer) 1
4) OK
5) OK
127.0.0.1:6379>
```

>放弃事务

```shell
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED
127.0.0.1:6379(TX)> set k4 v4
QUEUED
127.0.0.1:6379(TX)> DISCARD	#放弃事务，队列中命令都不会被执行
OK
127.0.0.1:6379> get k4
(nil)
```

>编译型异常（代码有问题！命令有错！），事务中的所有命令都不会被执行！
>
>运行时异常（1/0），如果事务队列中存在语法性错误，其它的命令可以正常执行，错误命令抛出异常！



>监控

**悲观锁：**

- 很悲观，认为什么时候都会出问题，无论做什么都会加锁

**乐观锁：**

- 很乐观，任务什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据
- 获取version
- 更新的时候比较version

>Redis监视测试

正常执行

```shell
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> WATCH money #监视money是否被修改
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY money 20
QUEUED
127.0.0.1:6379(TX)> INCRBY out 20
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 80
2) (integer) 20
127.0.0.1:6379>
```

测试多线程修改值，使用watch可以当作redis的乐观锁操作。

另一个线程在事务提交之前修改了money的值，所以事务执行失败

如果发现事务执行失败，就先解锁，再去获取最新的值，也就是version，再次监视

```shell
127.0.0.1:6379> UNWATCH #解锁
```

### 4.1、Jedis

>通过java来操作redis要使用jedis
>
>需要修改服务器的redis配置
>
>首先修改bind，后面加上真实的服务器IP地址
>
>然后将守护模式关闭，改为no。重启redis
>
>最后将服务器的防火墙关闭
